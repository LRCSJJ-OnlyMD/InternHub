{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, inject, ElementRef, ChangeDetectorRef, Input, Directive, Pipe, NgModule } from '@angular/core';\nimport { of, Subject, isObservable, forkJoin, concat, defer } from 'rxjs';\nimport { take, shareReplay, map, concatMap, switchMap } from 'rxjs/operators';\nfunction _(key) {\n  return key;\n}\nclass MissingTranslationHandler {}\n/**\n * This handler is just a placeholder that does nothing; in case you don't need a missing translation handler at all\n */\nlet DefaultMissingTranslationHandler = /*#__PURE__*/(() => {\n  class DefaultMissingTranslationHandler {\n    handle(params) {\n      return params.key;\n    }\n    static ɵfac = function DefaultMissingTranslationHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultMissingTranslationHandler)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultMissingTranslationHandler,\n      factory: DefaultMissingTranslationHandler.ɵfac\n    });\n  }\n  return DefaultMissingTranslationHandler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass TranslateCompiler {}\n/**\n * This compiler is just a placeholder that does nothing; in case you don't need a compiler at all\n */\nlet TranslateNoOpCompiler = /*#__PURE__*/(() => {\n  class TranslateNoOpCompiler extends TranslateCompiler {\n    compile(value, lang) {\n      void lang;\n      return value;\n    }\n    compileTranslations(translations, lang) {\n      void lang;\n      return translations;\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵTranslateNoOpCompiler_BaseFactory;\n      return function TranslateNoOpCompiler_Factory(__ngFactoryType__) {\n        return (ɵTranslateNoOpCompiler_BaseFactory || (ɵTranslateNoOpCompiler_BaseFactory = i0.ɵɵgetInheritedFactory(TranslateNoOpCompiler)))(__ngFactoryType__ || TranslateNoOpCompiler);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslateNoOpCompiler,\n      factory: TranslateNoOpCompiler.ɵfac\n    });\n  }\n  return TranslateNoOpCompiler;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass TranslateLoader {}\n/**\n * This loader is just a placeholder that does nothing; in case you don't need a loader at all\n */\nlet TranslateNoOpLoader = /*#__PURE__*/(() => {\n  class TranslateNoOpLoader extends TranslateLoader {\n    getTranslation(lang) {\n      void lang;\n      return of({});\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵTranslateNoOpLoader_BaseFactory;\n      return function TranslateNoOpLoader_Factory(__ngFactoryType__) {\n        return (ɵTranslateNoOpLoader_BaseFactory || (ɵTranslateNoOpLoader_BaseFactory = i0.ɵɵgetInheritedFactory(TranslateNoOpLoader)))(__ngFactoryType__ || TranslateNoOpLoader);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslateNoOpLoader,\n      factory: TranslateNoOpLoader.ɵfac\n    });\n  }\n  return TranslateNoOpLoader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Determines if two objects or two values are equivalent.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `equals`.\n *\n * @param o1 Object or value to compare.\n * @param o2 Object or value to compare.\n * @returns true if arguments are equal.\n */\nfunction equals(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n  const t1 = typeof o1,\n    t2 = typeof o2;\n  let length;\n  if (t1 == t2 && t1 == \"object\") {\n    if (Array.isArray(o1)) {\n      if (!Array.isArray(o2)) return false;\n      if ((length = o1.length) == o2.length) {\n        for (let key = 0; key < length; key++) {\n          if (!equals(o1[key], o2[key])) return false;\n        }\n        return true;\n      }\n    } else {\n      if (Array.isArray(o2)) {\n        return false;\n      }\n      if (isDict(o1) && isDict(o2)) {\n        const keySet = Object.create(null);\n        for (const key in o1) {\n          if (!equals(o1[key], o2[key])) {\n            return false;\n          }\n          keySet[key] = true;\n        }\n        for (const key in o2) {\n          if (!(key in keySet) && typeof o2[key] !== \"undefined\") {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isDefinedAndNotNull(value) {\n  return typeof value !== \"undefined\" && value !== null;\n}\nfunction isDefined(value) {\n  return value !== undefined;\n}\nfunction isDict(value) {\n  return isObject(value) && !isArray(value) && value !== null;\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction cloneDeep(value) {\n  if (isArray(value)) {\n    return value.map(item => cloneDeep(item));\n  } else if (isDict(value)) {\n    const cloned = {};\n    Object.keys(value).forEach(key => {\n      cloned[key] = cloneDeep(value[key]);\n    });\n    return cloned;\n  } else {\n    return value;\n  }\n}\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nfunction mergeDeep(target, source) {\n  if (!isObject(target)) {\n    return cloneDeep(source);\n  }\n  const output = cloneDeep(target);\n  if (isObject(output) && isObject(source)) {\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    Object.keys(source).forEach(key => {\n      if (isDict(source[key])) {\n        if (key in target) {\n          output[key] = mergeDeep(target[key], source[key]);\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n  return output;\n}\n/**\n * Retrieves a value from a nested object using a dot-separated key path.\n *\n * Example usage:\n * ```ts\n * getValue({ key1: { keyA: 'valueI' }}, 'key1.keyA'); // returns 'valueI'\n * ```\n *\n * @param target The source object from which to retrieve the value.\n * @param key Dot-separated key path specifying the value to retrieve.\n * @returns The value at the specified key path, or `undefined` if not found.\n */\nfunction getValue(target, key) {\n  const keys = key.split(\".\");\n  key = \"\";\n  do {\n    key += keys.shift();\n    const isLastKey = !keys.length;\n    if (isDefinedAndNotNull(target)) {\n      if (isDict(target) && isDefined(target[key]) && (isDict(target[key]) || isArray(target[key]) || isLastKey)) {\n        target = target[key];\n        key = \"\";\n        continue;\n      }\n      if (isArray(target)) {\n        const index = parseInt(key, 10);\n        if (isDefined(target[index]) && (isDict(target[index]) || isArray(target[index]) || isLastKey)) {\n          target = target[index];\n          key = \"\";\n          continue;\n        }\n      }\n    }\n    if (isLastKey) {\n      target = undefined;\n      continue;\n    }\n    key += \".\";\n  } while (keys.length);\n  return target;\n}\n/**\n * Sets a value on object using a dot separated key.\n * This function modifies the object in place\n * parser.setValue({a:{b:{c: \"test\"}}}, 'a.b.c', \"test2\") ==> {a:{b:{c: \"test2\"}}}\n * @param target an object\n * @param key E.g. \"a.b.c\"\n * @param value to set\n * @deprecated use insertValue() instead\n */\nfunction setValue(target, key, value) {\n  const keys = key.split(\".\");\n  let current = target;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (i === keys.length - 1) {\n      current[key] = value;\n    } else {\n      current = current[key] && isDict(current[key]) ? current[key] : {};\n    }\n  }\n}\n/**\n * Sets a value on object using a dot separated key.\n * Returns a clone of the object without modifying it\n * parser.setValue({a:{b:{c: \"test\"}}}, 'a.b.c', \"test2\") ==> {a:{b:{c: \"test2\"}}}\n * @param target an object\n * @param key E.g. \"a.b.c\"\n * @param value to set\n */\nfunction insertValue(target, key, value) {\n  return mergeDeep(target, createNestedObject(key, value));\n}\nfunction createNestedObject(dotSeparatedKey, value) {\n  return dotSeparatedKey.split(\".\").reduceRight((acc, key) => ({\n    [key]: acc\n  }), value);\n}\nclass TranslateParser {}\nlet TranslateDefaultParser = /*#__PURE__*/(() => {\n  class TranslateDefaultParser extends TranslateParser {\n    templateMatcher = /{{\\s?([^{}\\s]*)\\s?}}/g;\n    interpolate(expr, params) {\n      if (isString(expr)) {\n        return this.interpolateString(expr, params);\n      } else if (isFunction(expr)) {\n        return this.interpolateFunction(expr, params);\n      }\n      return undefined;\n    }\n    interpolateFunction(fn, params) {\n      return fn(params);\n    }\n    interpolateString(expr, params) {\n      if (!params) {\n        return expr;\n      }\n      return expr.replace(this.templateMatcher, (substring, key) => {\n        const replacement = this.getInterpolationReplacement(params, key);\n        return replacement !== undefined ? replacement : substring;\n      });\n    }\n    /**\n     * Returns the replacement for an interpolation parameter\n     * @params:\n     */\n    getInterpolationReplacement(params, key) {\n      return this.formatValue(getValue(params, key));\n    }\n    /**\n     * Converts a value into a useful string representation.\n     * @param value The value to format.\n     * @returns A string representation of the value.\n     */\n    formatValue(value) {\n      if (isString(value)) {\n        return value;\n      }\n      if (typeof value === \"number\" || typeof value === \"boolean\") {\n        return value.toString();\n      }\n      if (value === null) {\n        return \"null\";\n      }\n      if (isArray(value)) {\n        return value.join(\", \");\n      }\n      if (isObject(value)) {\n        if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) {\n          return value.toString();\n        }\n        return JSON.stringify(value); // Pretty-print JSON if no meaningful toString()\n      }\n      return undefined;\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵTranslateDefaultParser_BaseFactory;\n      return function TranslateDefaultParser_Factory(__ngFactoryType__) {\n        return (ɵTranslateDefaultParser_BaseFactory || (ɵTranslateDefaultParser_BaseFactory = i0.ɵɵgetInheritedFactory(TranslateDefaultParser)))(__ngFactoryType__ || TranslateDefaultParser);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslateDefaultParser,\n      factory: TranslateDefaultParser.ɵfac\n    });\n  }\n  return TranslateDefaultParser;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslateStore = /*#__PURE__*/(() => {\n  class TranslateStore {\n    _onTranslationChange = new Subject();\n    _onLangChange = new Subject();\n    _onFallbackLangChange = new Subject();\n    fallbackLang = null;\n    currentLang;\n    translations = {};\n    languages = [];\n    getTranslations(language) {\n      return this.translations[language];\n    }\n    setTranslations(language, translations, extend) {\n      this.translations[language] = extend && this.hasTranslationFor(language) ? mergeDeep(this.translations[language], translations) : translations;\n      this.addLanguages([language]);\n      this._onTranslationChange.next({\n        lang: language,\n        translations: this.getTranslations(language)\n      });\n    }\n    getLanguages() {\n      return this.languages;\n    }\n    getCurrentLang() {\n      return this.currentLang;\n    }\n    getFallbackLang() {\n      return this.fallbackLang;\n    }\n    /**\n     * Changes the fallback lang\n     */\n    setFallbackLang(lang, emitChange = true) {\n      this.fallbackLang = lang;\n      if (emitChange) {\n        this._onFallbackLangChange.next({\n          lang: lang,\n          translations: this.translations[lang]\n        });\n      }\n    }\n    setCurrentLang(lang, emitChange = true) {\n      this.currentLang = lang;\n      if (emitChange) {\n        this._onLangChange.next({\n          lang: lang,\n          translations: this.translations[lang]\n        });\n      }\n    }\n    /**\n     * An Observable to listen to translation change events\n     * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onTranslationChange() {\n      return this._onTranslationChange.asObservable();\n    }\n    /**\n     * An Observable to listen to lang change events\n     * onLangChange.subscribe((params: LangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onLangChange() {\n      return this._onLangChange.asObservable();\n    }\n    /**\n     * An Observable to listen to fallback lang change events\n     * onFallbackLangChange.subscribe((params: FallbackLangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onFallbackLangChange() {\n      return this._onFallbackLangChange.asObservable();\n    }\n    addLanguages(languages) {\n      this.languages = Array.from(new Set([...this.languages, ...languages]));\n    }\n    hasTranslationFor(lang) {\n      return typeof this.translations[lang] !== \"undefined\";\n    }\n    deleteTranslations(lang) {\n      delete this.translations[lang];\n    }\n    getTranslation(key) {\n      let text = this.getValue(this.currentLang, key);\n      if (text === undefined && this.fallbackLang != null && this.fallbackLang !== this.currentLang) {\n        text = this.getValue(this.fallbackLang, key);\n      }\n      return text;\n    }\n    getValue(language, key) {\n      return getValue(this.getTranslations(language), key);\n    }\n    static ɵfac = function TranslateStore_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TranslateStore)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslateStore,\n      factory: TranslateStore.ɵfac\n    });\n  }\n  return TranslateStore;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TRANSLATE_SERVICE_CONFIG = new InjectionToken(\"TRANSLATE_CONFIG\");\nconst makeObservable = value => {\n  return isObservable(value) ? value : of(value);\n};\nclass ITranslateService {}\nlet TranslateService = /*#__PURE__*/(() => {\n  class TranslateService {\n    loadingTranslations;\n    pending = false;\n    _translationRequests = {};\n    lastUseLanguage = null;\n    currentLoader = inject(TranslateLoader);\n    compiler = inject(TranslateCompiler);\n    parser = inject(TranslateParser);\n    missingTranslationHandler = inject(MissingTranslationHandler);\n    store = inject(TranslateStore);\n    extend = false;\n    /**\n     * An Observable to listen to translation change events\n     * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onTranslationChange() {\n      return this.store.onTranslationChange;\n    }\n    /**\n     * An Observable to listen to lang change events\n     * onLangChange.subscribe((params: LangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onLangChange() {\n      return this.store.onLangChange;\n    }\n    /**\n     * An Observable to listen to fallback lang change events\n     * onFallbackLangChange.subscribe((params: FallbackLangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onFallbackLangChange() {\n      return this.store.onFallbackLangChange;\n    }\n    /**\n     * @deprecated Use onFallbackLangChange() instead\n     */\n    get onDefaultLangChange() {\n      return this.store.onFallbackLangChange;\n    }\n    constructor() {\n      const config = {\n        extend: false,\n        fallbackLang: null,\n        ...inject(TRANSLATE_SERVICE_CONFIG, {\n          optional: true\n        })\n      };\n      if (config.lang) {\n        this.use(config.lang);\n      }\n      if (config.fallbackLang) {\n        this.setFallbackLang(config.fallbackLang);\n      }\n      if (config.extend) {\n        this.extend = true;\n      }\n    }\n    /**\n     * Sets the fallback language to use if a translation is not found in the\n     * current language\n     */\n    setFallbackLang(lang) {\n      if (!this.getFallbackLang()) {\n        // on init set the fallbackLang immediately, but do not emit a change yet\n        this.store.setFallbackLang(lang, false);\n      }\n      const pending = this.loadOrExtendLanguage(lang);\n      if (isObservable(pending)) {\n        pending.pipe(take(1)).subscribe({\n          next: () => {\n            this.store.setFallbackLang(lang);\n          },\n          error: () => {\n            /* ignore here - user can handle it */\n          }\n        });\n        return pending;\n      }\n      this.store.setFallbackLang(lang);\n      return of(this.store.getTranslations(lang));\n    }\n    /**\n     * Changes the lang currently used\n     */\n    use(lang) {\n      // remember the language that was called\n      // we need this with multiple fast calls to use()\n      // where translation loads might complete in random order\n      this.lastUseLanguage = lang;\n      if (!this.getCurrentLang()) {\n        // on init set the currentLang immediately, but do not emit a change yet\n        this.store.setCurrentLang(lang, false);\n      }\n      const pending = this.loadOrExtendLanguage(lang);\n      if (isObservable(pending)) {\n        pending.pipe(take(1)).subscribe({\n          next: () => {\n            this.changeLang(lang);\n          },\n          error: () => {\n            /* ignore here - use can handle it */\n          }\n        });\n        return pending;\n      }\n      this.changeLang(lang);\n      return of(this.store.getTranslations(lang));\n    }\n    /**\n     * Retrieves the given translations\n     */\n    loadOrExtendLanguage(lang) {\n      // if this language is unavailable or extend is true, ask for it\n      if (!this.store.hasTranslationFor(lang) || this.extend) {\n        this._translationRequests[lang] = this._translationRequests[lang] || this.loadAndCompileTranslations(lang);\n        return this._translationRequests[lang];\n      }\n      return undefined;\n    }\n    /**\n     * Changes the current lang\n     */\n    changeLang(lang) {\n      if (lang !== this.lastUseLanguage) {\n        // received new language data,\n        // but this was not the one requested last\n        return;\n      }\n      this.store.setCurrentLang(lang);\n    }\n    getCurrentLang() {\n      return this.store.getCurrentLang();\n    }\n    loadAndCompileTranslations(lang) {\n      this.pending = true;\n      const loadingTranslations = this.currentLoader.getTranslation(lang).pipe(shareReplay(1), take(1));\n      this.loadingTranslations = loadingTranslations.pipe(map(res => this.compiler.compileTranslations(res, lang)), shareReplay(1), take(1));\n      this.loadingTranslations.subscribe({\n        next: res => {\n          this.store.setTranslations(lang, res, this.extend);\n          this.pending = false;\n        },\n        error: err => {\n          void err;\n          this.pending = false;\n        }\n      });\n      return loadingTranslations;\n    }\n    /**\n     * Manually sets an object of translations for a given language\n     * after passing it through the compiler\n     */\n    setTranslation(lang, translations, shouldMerge = false) {\n      const interpolatableTranslations = this.compiler.compileTranslations(translations, lang);\n      this.store.setTranslations(lang, interpolatableTranslations, shouldMerge || this.extend);\n    }\n    getLangs() {\n      return this.store.getLanguages();\n    }\n    /**\n     * Add available languages\n     */\n    addLangs(languages) {\n      this.store.addLanguages(languages);\n    }\n    getParsedResultForKey(key, interpolateParams) {\n      const textToInterpolate = this.getTextToInterpolate(key);\n      if (isDefinedAndNotNull(textToInterpolate)) {\n        return this.runInterpolation(textToInterpolate, interpolateParams);\n      }\n      const res = this.missingTranslationHandler.handle({\n        key,\n        translateService: this,\n        ...(interpolateParams !== undefined && {\n          interpolateParams\n        })\n      });\n      return res !== undefined ? res : key;\n    }\n    /**\n     * Gets the fallback language. null if none is defined\n     */\n    getFallbackLang() {\n      return this.store.getFallbackLang();\n    }\n    getTextToInterpolate(key) {\n      return this.store.getTranslation(key);\n    }\n    runInterpolation(translations, interpolateParams) {\n      if (!isDefinedAndNotNull(translations)) {\n        return;\n      }\n      if (isArray(translations)) {\n        return this.runInterpolationOnArray(translations, interpolateParams);\n      }\n      if (isDict(translations)) {\n        return this.runInterpolationOnDict(translations, interpolateParams);\n      }\n      return this.parser.interpolate(translations, interpolateParams);\n    }\n    runInterpolationOnArray(translations, interpolateParams) {\n      return translations.map(translation => this.runInterpolation(translation, interpolateParams));\n    }\n    runInterpolationOnDict(translations, interpolateParams) {\n      const result = {};\n      for (const key in translations) {\n        const res = this.runInterpolation(translations[key], interpolateParams);\n        if (res !== undefined) {\n          result[key] = res;\n        }\n      }\n      return result;\n    }\n    /**\n     * Returns the parsed result of the translations\n     */\n    getParsedResult(key, interpolateParams) {\n      return key instanceof Array ? this.getParsedResultForArray(key, interpolateParams) : this.getParsedResultForKey(key, interpolateParams);\n    }\n    getParsedResultForArray(key, interpolateParams) {\n      const result = {};\n      let observables = false;\n      for (const k of key) {\n        result[k] = this.getParsedResultForKey(k, interpolateParams);\n        observables = observables || isObservable(result[k]);\n      }\n      if (!observables) {\n        return result;\n      }\n      const sources = key.map(k => makeObservable(result[k]));\n      return forkJoin(sources).pipe(map(arr => {\n        const obj = {};\n        arr.forEach((value, index) => {\n          obj[key[index]] = value;\n        });\n        return obj;\n      }));\n    }\n    /**\n     * Gets the translated value of a key (or an array of keys)\n     * @returns the translated key, or an object of translated keys\n     */\n    get(key, interpolateParams) {\n      if (!isDefinedAndNotNull(key) || !key.length) {\n        throw new Error(`Parameter \"key\" is required and cannot be empty`);\n      }\n      // check if we are loading a new translation to use\n      if (this.pending) {\n        return this.loadingTranslations.pipe(concatMap(() => {\n          return makeObservable(this.getParsedResult(key, interpolateParams));\n        }));\n      }\n      return makeObservable(this.getParsedResult(key, interpolateParams));\n    }\n    /**\n     * Returns a stream of translated values of a key (or an array of keys) which updates\n     * whenever the translation changes.\n     * @returns A stream of the translated key, or an object of translated keys\n     */\n    getStreamOnTranslationChange(key, interpolateParams) {\n      if (!isDefinedAndNotNull(key) || !key.length) {\n        throw new Error(`Parameter \"key\" is required and cannot be empty`);\n      }\n      return concat(defer(() => this.get(key, interpolateParams)), this.onTranslationChange.pipe(switchMap(() => {\n        const res = this.getParsedResult(key, interpolateParams);\n        return makeObservable(res);\n      })));\n    }\n    /**\n     * Returns a stream of translated values of a key (or an array of keys) which updates\n     * whenever the language changes.\n     * @returns A stream of the translated key, or an object of translated keys\n     */\n    stream(key, interpolateParams) {\n      if (!isDefinedAndNotNull(key) || !key.length) {\n        throw new Error(`Parameter \"key\" required`);\n      }\n      return concat(defer(() => this.get(key, interpolateParams)), this.onLangChange.pipe(switchMap(() => {\n        const res = this.getParsedResult(key, interpolateParams);\n        return makeObservable(res);\n      })));\n    }\n    /**\n     * Returns a translation instantly from the internal state of loaded translation.\n     * All rules regarding the current language, the preferred language of even fallback languages\n     * will be used except any promise handling.\n     */\n    instant(key, interpolateParams) {\n      if (!isDefinedAndNotNull(key) || key.length === 0) {\n        throw new Error('Parameter \"key\" is required and cannot be empty');\n      }\n      const result = this.getParsedResult(key, interpolateParams);\n      if (isObservable(result)) {\n        if (Array.isArray(key)) {\n          return key.reduce((acc, currKey) => {\n            acc[currKey] = currKey;\n            return acc;\n          }, {});\n        }\n        return key;\n      }\n      return result;\n    }\n    /**\n     * Sets the translated value of a key, after compiling it\n     */\n    set(key, translation, lang = this.getCurrentLang()) {\n      this.store.setTranslations(lang, insertValue(this.store.getTranslations(lang), key, isString(translation) ? this.compiler.compile(translation, lang) : this.compiler.compileTranslations(translation, lang)), false);\n    }\n    /**\n     * Allows reloading the lang file from the file\n     */\n    reloadLang(lang) {\n      this.resetLang(lang);\n      return this.loadAndCompileTranslations(lang);\n    }\n    /**\n     * Deletes inner translation\n     */\n    resetLang(lang) {\n      delete this._translationRequests[lang];\n      this.store.deleteTranslations(lang);\n    }\n    /**\n     * Returns the language code name from the browser, e.g. \"de\"\n     */\n    static getBrowserLang() {\n      if (typeof window === \"undefined\" || !window.navigator) {\n        return undefined;\n      }\n      const browserLang = this.getBrowserCultureLang();\n      return browserLang ? browserLang.split(/[-_]/)[0] : undefined;\n    }\n    /**\n     * Returns the culture language code name from the browser, e.g. \"de-DE\"\n     */\n    static getBrowserCultureLang() {\n      if (typeof window === \"undefined\" || typeof window.navigator === \"undefined\") {\n        return undefined;\n      }\n      return window.navigator.languages ? window.navigator.languages[0] : window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;\n    }\n    getBrowserLang() {\n      return TranslateService.getBrowserLang();\n    }\n    getBrowserCultureLang() {\n      return TranslateService.getBrowserCultureLang();\n    }\n    /** Deprecations **/\n    /**\n     * @deprecated use `getFallbackLang()`\n     */\n    get defaultLang() {\n      return this.getFallbackLang();\n    }\n    /**\n     * The lang currently used\n     * @deprecated use `getCurrentLang()`\n     */\n    get currentLang() {\n      return this.store.getCurrentLang();\n    }\n    /**\n     * @deprecated use `getLangs()`\n     */\n    get langs() {\n      return this.store.getLanguages();\n    }\n    /**\n     * Sets the  language to use as a fallback\n     * @deprecated use setFallbackLanguage()\n     */\n    setDefaultLang(lang) {\n      return this.setFallbackLang(lang);\n    }\n    /**\n     * Gets the fallback language used\n     * @deprecated use getFallbackLang()\n     */\n    getDefaultLang() {\n      return this.getFallbackLang();\n    }\n    static ɵfac = function TranslateService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TranslateService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslateService,\n      factory: TranslateService.ɵfac\n    });\n  }\n  return TranslateService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslateDirective = /*#__PURE__*/(() => {\n  class TranslateDirective {\n    translateService = inject(TranslateService);\n    element = inject(ElementRef);\n    _ref = inject(ChangeDetectorRef);\n    key;\n    lastParams;\n    currentParams;\n    onLangChangeSub;\n    onFallbackLangChangeSub;\n    onTranslationChangeSub;\n    set translate(key) {\n      if (key) {\n        this.key = key;\n        this.checkNodes();\n      }\n    }\n    set translateParams(params) {\n      if (!equals(this.currentParams, params)) {\n        this.currentParams = params;\n        this.checkNodes(true);\n      }\n    }\n    constructor() {\n      // subscribe to onTranslationChange event, in case the translations of the current lang change\n      if (!this.onTranslationChangeSub) {\n        this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(event => {\n          if (event.lang === this.translateService.currentLang) {\n            this.checkNodes(true, event.translations);\n          }\n        });\n      }\n      // subscribe to onLangChange event, in case the language changes\n      if (!this.onLangChangeSub) {\n        this.onLangChangeSub = this.translateService.onLangChange.subscribe(event => {\n          this.checkNodes(true, event.translations);\n        });\n      }\n      // subscribe to onFallbackLangChange event, in case the fallback language changes\n      if (!this.onFallbackLangChangeSub) {\n        this.onFallbackLangChangeSub = this.translateService.onFallbackLangChange.subscribe(event => {\n          void event;\n          this.checkNodes(true);\n        });\n      }\n    }\n    ngAfterViewChecked() {\n      this.checkNodes();\n    }\n    checkNodes(forceUpdate = false, translations) {\n      let nodes = this.element.nativeElement.childNodes;\n      // if the element is empty\n      if (!nodes.length) {\n        // we add the key as content\n        this.setContent(this.element.nativeElement, this.key);\n        nodes = this.element.nativeElement.childNodes;\n      }\n      nodes.forEach(n => {\n        const node = n;\n        if (node.nodeType === 3) {\n          // node type 3 is a text node\n          let key;\n          if (forceUpdate) {\n            node.lastKey = null;\n          }\n          if (isDefinedAndNotNull(node.lookupKey)) {\n            key = node.lookupKey;\n          } else if (this.key) {\n            key = this.key;\n          } else {\n            const content = this.getContent(node);\n            const trimmedContent = content.trim();\n            if (trimmedContent.length) {\n              node.lookupKey = trimmedContent;\n              // we want to use the content as a key, not the translation value\n              if (content !== node.currentValue) {\n                key = trimmedContent;\n                // the content was changed from the user, we'll use it as a reference if needed\n                node.originalContent = content || node.originalContent;\n              } else if (node.originalContent) {\n                // the content seems ok, but the lang has changed\n                // the current content is the translation, not the key, use the last real content as key\n                key = node.originalContent.trim();\n              }\n            }\n          }\n          this.updateValue(key, node, translations);\n        }\n      });\n    }\n    updateValue(key, node, translations) {\n      if (key) {\n        if (node.lastKey === key && this.lastParams === this.currentParams) {\n          return;\n        }\n        this.lastParams = this.currentParams;\n        const onTranslation = res => {\n          if (res !== key || !node.lastKey) {\n            node.lastKey = key;\n          }\n          if (!node.originalContent) {\n            node.originalContent = this.getContent(node);\n          }\n          if (isString(res)) {\n            node.currentValue = res;\n          } else if (!isDefinedAndNotNull(res)) {\n            node.currentValue = node.originalContent || key;\n          } else {\n            node.currentValue = JSON.stringify(res);\n          }\n          // we replace in the original content to preserve spaces that we might have trimmed\n          this.setContent(node, this.key ? node.currentValue : node.originalContent.replace(key, node.currentValue));\n          this._ref.markForCheck();\n        };\n        if (isDefinedAndNotNull(translations)) {\n          const res = this.translateService.getParsedResult(key, this.currentParams);\n          if (isObservable(res)) {\n            res.subscribe({\n              next: onTranslation\n            });\n          } else {\n            onTranslation(res);\n          }\n        } else {\n          this.translateService.get(key, this.currentParams).subscribe(onTranslation);\n        }\n      }\n    }\n    getContent(node) {\n      return isDefinedAndNotNull(node.textContent) ? node.textContent : node.data;\n    }\n    setContent(node, content) {\n      if (isDefinedAndNotNull(node.textContent)) {\n        node.textContent = content;\n      } else {\n        node.data = content;\n      }\n    }\n    ngOnDestroy() {\n      if (this.onLangChangeSub) {\n        this.onLangChangeSub.unsubscribe();\n      }\n      if (this.onFallbackLangChangeSub) {\n        this.onFallbackLangChangeSub.unsubscribe();\n      }\n      if (this.onTranslationChangeSub) {\n        this.onTranslationChangeSub.unsubscribe();\n      }\n    }\n    static ɵfac = function TranslateDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TranslateDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TranslateDirective,\n      selectors: [[\"\", \"translate\", \"\"], [\"\", \"ngx-translate\", \"\"]],\n      inputs: {\n        translate: \"translate\",\n        translateParams: \"translateParams\"\n      }\n    });\n  }\n  return TranslateDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslatePipe = /*#__PURE__*/(() => {\n  class TranslatePipe {\n    translate = inject(TranslateService);\n    _ref = inject(ChangeDetectorRef);\n    value = \"\";\n    lastKey = null;\n    lastParams = [];\n    onTranslationChange;\n    onLangChange;\n    onFallbackLangChange;\n    updateValue(key, interpolateParams, translations) {\n      const onTranslation = res => {\n        this.value = res !== undefined ? res : key;\n        this.lastKey = key;\n        this._ref.markForCheck();\n      };\n      if (translations) {\n        const res = this.translate.getParsedResult(key, interpolateParams);\n        if (isObservable(res)) {\n          res.subscribe(onTranslation);\n        } else {\n          onTranslation(res);\n        }\n      }\n      this.translate.get(key, interpolateParams).subscribe(onTranslation);\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    transform(query, ...args) {\n      if (!query || !query.length) {\n        return query;\n      }\n      // if we ask another time for the same key, return the last value\n      if (equals(query, this.lastKey) && equals(args, this.lastParams)) {\n        return this.value;\n      }\n      let interpolateParams = undefined;\n      if (isDefinedAndNotNull(args[0]) && args.length) {\n        if (isString(args[0]) && args[0].length) {\n          // we accept objects written in the template such as {n:1}, {'n':1}, {n:'v'}\n          // this is why we might need to change it to real JSON objects such as {\"n\":1} or {\"n\":\"v\"}\n          const validArgs = args[0].replace(/(')?([a-zA-Z0-9_]+)(')?(\\s)?:/g, '\"$2\":').replace(/:(\\s)?(')(.*?)(')/g, ':\"$3\"');\n          try {\n            interpolateParams = JSON.parse(validArgs);\n          } catch (e) {\n            void e;\n            throw new SyntaxError(`Wrong parameter in TranslatePipe. Expected a valid Object, received: ${args[0]}`);\n          }\n        } else if (isDict(args[0])) {\n          interpolateParams = args[0];\n        }\n      }\n      // store the query in case it changes\n      this.lastKey = query;\n      // store the params in case they change\n      this.lastParams = args;\n      // set the value\n      this.updateValue(query, interpolateParams);\n      // if there is a subscription to onLangChange, clean it\n      this._dispose();\n      // subscribe to onTranslationChange event, in case the translations change\n      if (!this.onTranslationChange) {\n        this.onTranslationChange = this.translate.onTranslationChange.subscribe(event => {\n          if (this.lastKey && event.lang === this.translate.getCurrentLang() || event.lang === this.translate.getFallbackLang()) {\n            this.lastKey = null;\n            this.updateValue(query, interpolateParams, event.translations);\n          }\n        });\n      }\n      // subscribe to onLangChange event, in case the language changes\n      if (!this.onLangChange) {\n        this.onLangChange = this.translate.onLangChange.subscribe(event => {\n          if (this.lastKey) {\n            this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n            this.updateValue(query, interpolateParams, event.translations);\n          }\n        });\n      }\n      // subscribe to onDefaultLangChange event, in case the fallback language changes\n      if (!this.onFallbackLangChange) {\n        this.onFallbackLangChange = this.translate.onFallbackLangChange.subscribe(() => {\n          if (this.lastKey) {\n            this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n            this.updateValue(query, interpolateParams);\n          }\n        });\n      }\n      return this.value;\n    }\n    /**\n     * Clean any existing subscription to change events\n     */\n    _dispose() {\n      if (typeof this.onTranslationChange !== \"undefined\") {\n        this.onTranslationChange.unsubscribe();\n        this.onTranslationChange = undefined;\n      }\n      if (typeof this.onLangChange !== \"undefined\") {\n        this.onLangChange.unsubscribe();\n        this.onLangChange = undefined;\n      }\n      if (typeof this.onFallbackLangChange !== \"undefined\") {\n        this.onFallbackLangChange.unsubscribe();\n        this.onFallbackLangChange = undefined;\n      }\n    }\n    ngOnDestroy() {\n      this._dispose();\n    }\n    static ɵfac = function TranslatePipe_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TranslatePipe)();\n    };\n    static ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n      name: \"translate\",\n      type: TranslatePipe,\n      pure: false\n    });\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TranslatePipe,\n      factory: TranslatePipe.ɵfac\n    });\n  }\n  return TranslatePipe;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideTranslateLoader(loader) {\n  return {\n    provide: TranslateLoader,\n    useClass: loader\n  };\n}\nfunction provideTranslateCompiler(compiler) {\n  return {\n    provide: TranslateCompiler,\n    useClass: compiler\n  };\n}\nfunction provideTranslateParser(parser) {\n  return {\n    provide: TranslateParser,\n    useClass: parser\n  };\n}\nfunction provideMissingTranslationHandler(handler) {\n  return {\n    provide: MissingTranslationHandler,\n    useClass: handler\n  };\n}\nfunction provideTranslateService(config = {}) {\n  return defaultProviders({\n    compiler: provideTranslateCompiler(TranslateNoOpCompiler),\n    parser: provideTranslateParser(TranslateDefaultParser),\n    loader: provideTranslateLoader(TranslateNoOpLoader),\n    missingTranslationHandler: provideMissingTranslationHandler(DefaultMissingTranslationHandler),\n    ...config\n  }, true);\n}\nfunction provideChildTranslateService(config = {}) {\n  return defaultProviders({\n    extend: true,\n    ...config\n  }, false);\n}\nfunction defaultProviders(config = {}, provideStore) {\n  const providers = [];\n  if (config.loader) {\n    providers.push(config.loader);\n  }\n  if (config.compiler) {\n    providers.push(config.compiler);\n  }\n  if (config.parser) {\n    providers.push(config.parser);\n  }\n  if (config.missingTranslationHandler) {\n    providers.push(config.missingTranslationHandler);\n  }\n  if (provideStore) {\n    providers.push(TranslateStore);\n  }\n  if (config.useDefaultLang || config.defaultLanguage) {\n    console.warn(\"The `useDefaultLang` and `defaultLanguage` options are deprecated. Please use `fallbackLang` instead.\");\n    if (config.useDefaultLang === true && config.defaultLanguage) {\n      config.fallbackLang = config.defaultLanguage;\n    }\n  }\n  const serviceConfig = {\n    fallbackLang: config.fallbackLang ?? null,\n    lang: config.lang,\n    extend: config.extend ?? false\n  };\n  providers.push({\n    provide: TRANSLATE_SERVICE_CONFIG,\n    useValue: serviceConfig\n  });\n  providers.push({\n    provide: TranslateService,\n    useClass: TranslateService,\n    deps: [TranslateStore, TranslateLoader, TranslateCompiler, TranslateParser, MissingTranslationHandler, TRANSLATE_SERVICE_CONFIG]\n  });\n  return providers;\n}\nlet TranslateModule = /*#__PURE__*/(() => {\n  class TranslateModule {\n    /**\n     * Use this method in your root module to provide the TranslateService\n     */\n    static forRoot(config = {}) {\n      return {\n        ngModule: TranslateModule,\n        providers: [...defaultProviders({\n          compiler: provideTranslateCompiler(TranslateNoOpCompiler),\n          parser: provideTranslateParser(TranslateDefaultParser),\n          loader: provideTranslateLoader(TranslateNoOpLoader),\n          missingTranslationHandler: provideMissingTranslationHandler(DefaultMissingTranslationHandler),\n          ...config\n        }, true)]\n      };\n    }\n    /**\n     * Use this method in your other (non-root) modules to import the directive/pipe\n     */\n    static forChild(config = {}) {\n      return {\n        ngModule: TranslateModule,\n        providers: [...defaultProviders(config, config.isolate ?? false)]\n      };\n    }\n    static ɵfac = function TranslateModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TranslateModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: TranslateModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return TranslateModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultMissingTranslationHandler, ITranslateService, MissingTranslationHandler, TRANSLATE_SERVICE_CONFIG, TranslateCompiler, TranslateDefaultParser, TranslateDirective, TranslateLoader, TranslateModule, TranslateNoOpCompiler, TranslateNoOpLoader, TranslateParser, TranslatePipe, TranslateService, TranslateStore, _, defaultProviders, equals, getValue, insertValue, isArray, isDefined, isDefinedAndNotNull, isDict, isFunction, isObject, isString, mergeDeep, provideChildTranslateService, provideMissingTranslationHandler, provideTranslateCompiler, provideTranslateLoader, provideTranslateParser, provideTranslateService, setValue };\n//# sourceMappingURL=ngx-translate-core.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}